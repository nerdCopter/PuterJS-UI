<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title></title> <!-- Placeholder title removed -->
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <script src="https://js.puter.com/v2/"></script>
  <style>
    body {
      font-family: Georgia, "Times New Roman", Times, serif; /* Changed to a standard serif font stack */
      background: #f6f8fa;
      margin: 0;
      padding: 0;
    }
    #container { width: 80vw; margin: 40px auto; background: #fff; border-radius: 10px; box-shadow: 0 4px 24px rgba(0,0,0,0.08); padding: 24px; }
    #messages { min-height: 10px; margin-bottom: 6px; border-bottom: 1px solid #eee; padding-bottom: 16px; }
    .msg { margin: 8px 0; } /* Reintroduced vertical margin for whitespace between bubbles */
    .msg.user { text-align: right; color: #000000; } /* Changed user message color to black */
    .msg.ai { text-align: left; color: #000000; } /* Changed AI message color to black */
    .msg .bubble {
      display: inline-block;
      padding: 4px 6px; /* Adjusted for very short vertical (4px) and slightly narrower horizontal (6px) padding */
      border-radius: 4px; /* Adjusted border-radius to match smaller padding */
      margin-bottom: 0; /* Ensure no extra margin below the bubble itself */
    }
    .msg.user .bubble { background: #dbeafe; }
    .msg.ai .bubble { background: #f3f4f6; }
    #input-row { display: flex; gap: 8px; margin-top: 12px; }
    #user-input {
      flex: 1;
      padding: 10px;
      border: 1px solid #d1d5db;
      border-radius: 8px;
      font-size: 1rem;
      resize: none; /* Prevent manual resizing by the user */
      overflow-y: hidden; /* Hide scrollbar, as we're auto-growing */
      min-height: 40px; /* Set a minimum height for the textarea */
      box-sizing: border-box; /* Include padding and border in the element's total width and height */
      height: auto; /* Allow height to be controlled by JS */
    }
    #send-btn, #attach-btn, #unload-btn { padding: 0 18px; border: none; border-radius: 8px; background: #2563eb; color: #fff; font-size: 1rem; cursor: pointer; }
    #attach-btn { background: #6b7280; }
    #unload-btn { background: #e11d48; }
    #send-btn:hover { background: #1d4ed8; }
    #attach-btn:hover { background: #374151; }
    #unload-btn:hover { background: #be123c; }
    #file-input { display: none; }
    #attached-file { font-size: 0.95em; color: #374151; margin-right: 8px; margin-top: 2px; }
    .markdown-body {
      font-size: 1.3em; /* Font size for non-code text */
      line-height: 1.2; /* Adjusted line-height for more compact text lines */
    }

    /* Styles for markdown code/pre */
    .markdown-body pre {
      border-radius: 3px;
      padding: 4px;
      /* Programmer font */
      font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', 'Liberation Mono', 'Menlo', 'Courier New', monospace;
      font-size: 0.8em; /* Decreased code font size relative to the new markdown-body size */
    }
    .markdown-body code { /* Inline code */
      border-radius: 3px;
      padding: 2px 4px;
      font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', 'Liberation Mono', 'Menlo', 'Courier New', monospace;
      font-size: 0.8em;
    }

    /* Remove default top/bottom margins from common markdown-generated block elements */
    .markdown-body p,
    .markdown-body ul,
    .markdown-body ol,
    .markdown-body h1,
    .markdown-body h2,
    .markdown-body h3,
    .markdown-body h4,
    .markdown-body h5,
    .markdown-body h6 {
      margin-top: 2px; /* Very small top margin */
      margin-bottom: 2px; /* Very small bottom margin */
    }

    /* Style for the copy button */
    .copy-code-btn {
      display: inline-block; /* Changed to inline-block for float */
      margin-top: 5px; /* Margin to separate from the code block above */
      padding: 4px 8px;
      font-size: 0.8em;
      cursor: pointer;
      background-color: #2563eb; /* Changed to blue */
      border: 1px solid #1d4ed8; /* Darker blue border */
      border-radius: 4px;
      color: #fff; /* White text */
      float: right; /* Position to the right */
      clear: both; /* Ensure it's below the pre if pre is block */
      user-select: none; /* Prevent text selection on the button */
    }

    .copy-code-btn:hover {
      background-color: #1d4ed8; /* Darker blue on hover */
    }

    .copy-code-btn:active {
      background-color: #111827; /* Even darker blue on active */
    }
  </style>
</head>
<body>
  <div id="container">
    <h2 id="chat-title"></h2> <!-- Added ID for dynamic update -->
    <div id="messages"></div>
    <div id="input-row">
      <span id="attached-file"></span>
      <textarea id="user-input" placeholder="Type your message or attach a file..." autocomplete="off" rows="1"></textarea>
      <button id="attach-btn" title="Attach file">📎</button>
      <input type="file" id="file-input" />
      <button id="unload-btn">Unload File</button>
      <button id="send-btn">Send</button>
    </div>
  </div>
  <script>
    const messagesDiv = document.getElementById('messages');
    const userInput = document.getElementById('user-input');
    const sendBtn = document.getElementById('send-btn');
    const attachBtn = document.getElementById('attach-btn');
    const unloadBtn = document.getElementById('unload-btn');
    const fileInput = document.getElementById('file-input');
    const attachedFileSpan = document.getElementById('attached-file');
    const chatTitle = document.getElementById('chat-title'); // Get the chat title element

    let fileContentPrompt = null;
    let fileNamePrompt = null;
    let fileName = null;
    // chatHistory will now store objects in the format expected by the API
    let chatHistory = [];

    // Reusable variable for the file analysis prompt template
    const fileAnalysisPromptTemplate = (name) => `Analyze \`${name}\` and provide a brief summary of its function.`; // Changed back to 'brief'

    // Define model and temperature
    const modelName = 'google/gemini-2.5-flash-preview:thinking';
    const temperatureValue = 0.3;

    // Update the document title and chat header on load
    document.title = `${modelName} (Temp: ${temperatureValue})`;
    chatTitle.textContent = `${modelName.split('/').pop().split(':')[0]} (Temp: ${temperatureValue})`;

    // Configure marked.js to convert GFM line breaks to <br> tags
    marked.setOptions({
      breaks: true
    });

    function renderMarkdown(md) {
      const div = document.createElement('div');
      div.className = 'markdown-body';
      div.innerHTML = marked.parse(md);
      return div;
    }

    function addMessage(text, sender = 'user', isStreamingPlaceholder = false) {
      console.log(`Adding message: "${text}" from ${sender}. Is placeholder: ${isStreamingPlaceholder}`); // Log message being added
      const msgDiv = document.createElement('div');
      msgDiv.className = `msg ${sender}`;
      let bubble = `<div class="bubble"></div>`;
      msgDiv.innerHTML = bubble;
      const bubbleElement = msgDiv.querySelector('.bubble'); // Get the bubble element

      if (text) {
        if (isStreamingPlaceholder) {
           bubbleElement.innerHTML = text; // Add "Thinking..." directly
        } else {
          const renderedContent = renderMarkdown(text);
          bubbleElement.appendChild(renderedContent); // Append the rendered markdown

          // If it's a completed AI message, add copy buttons to code blocks
          if (sender === 'ai') {
            const codeBlocks = renderedContent.querySelectorAll('pre');
            codeBlocks.forEach(pre => {
              const copyBtn = document.createElement('button');
              copyBtn.className = 'copy-code-btn';
              copyBtn.textContent = '📋 Copy'; // Clipboard icon and text
              // Insert the button after the pre element
              pre.parentNode.insertBefore(copyBtn, pre.nextSibling); // Insert after the pre element
            });
          }
        }
      }
      messagesDiv.appendChild(msgDiv);
      messagesDiv.scrollTop = messagesDiv.scrollHeight; // Auto-scroll to bottom
      return bubbleElement; // Return the bubble element for streaming updates
    }

    // Function to auto-grow the textarea
    function autoGrowTextarea(element) {
      element.style.height = 'auto'; // Reset height to recalculate scrollHeight
      element.style.height = element.scrollHeight + 'px'; // Set height to scrollHeight
    }

    function updateUnloadBtn() {
      console.log(`Updating unload button visibility. fileContentPrompt: ${!!fileContentPrompt}, fileNamePrompt: ${!!fileNamePrompt}`); // Log unload button state
      if (fileContentPrompt || fileNamePrompt) {
        unloadBtn.style.display = "inline-block";
      } else {
        unloadBtn.style.display = "none";
      }
    }

    function updateUserInputBox() {
      console.log(`Updating user input box. Current fileName: ${fileName}`); // Log input box state
      if (fileName) {
        userInput.value = fileAnalysisPromptTemplate(fileName);
      } else {
        userInput.value = '';
        userInput.placeholder = 'Type your message or attach a file...';
      }
      userInput.readOnly = false; // Always ensure it's editable unless explicitly set otherwise
      autoGrowTextarea(userInput); // Adjust height after updating value
    }

    unloadBtn.onclick = () => {
      console.log("Unload button clicked. Clearing file state."); // Log unload action
      fileContentPrompt = null;
      fileNamePrompt = null;
      fileName = null;
      attachedFileSpan.textContent = '';
      updateUnloadBtn();
      updateUserInputBox();
    };

    async function sendMessage() {
      console.log("sendMessage called."); // Log sendMessage start
      let text = userInput.value.trim();
      let userMessageForDisplay = text; // What the user sees they sent
      let messageContentForModel = text; // What is actually sent to the AI

      // Clear input field immediately after getting its value
      userInput.value = '';
      autoGrowTextarea(userInput); // Reset height after clearing

      // Check if a file is currently attached and this is the initial send
      if (fileContentPrompt && fileName) {
        console.log(`File attached. Preparing message with file content for model.`); // Log file handling
        // Construct the full message for the model including the file content
        messageContentForModel = `${userMessageForDisplay}\n\n${fileContentPrompt}`; // Use original input value + file content
        // userMessageForDisplay is already set to the content of userInput.value.trim() before clearing
        // So, userMessageForDisplay remains the text the user typed/saw in the input box.

        // Clear the file state immediately after constructing the message for this turn
        console.log("Clearing file state after sending."); // Log file state clear
        fileContentPrompt = null;
        fileNamePrompt = null;
        fileName = null;
        attachedFileSpan.textContent = '';
        updateUnloadBtn();
        updateUserInputBox(); // Reset input box and state
      } else if (!text) {
        // If no file is attached and the input is empty, do nothing
        console.log("Input was empty, not sending message."); // Log empty message attempt
        return;
      }

      // Add the user message to the display
      addMessage(userMessageForDisplay, 'user');

      // Add the user message content (what was sent to the model) to chat history
      chatHistory.push({ role: 'user', content: messageContentForModel });

      // Check for the specific "wait for my request" command
      if (userMessageForDisplay.toLowerCase() === "wait for my request") {
          console.log("User requested to wait. Responding with 'Awaiting your command.'");
          const aiResponseText = "Awaiting your command.";
          addMessage(aiResponseText, 'ai');
          chatHistory.push({ role: 'assistant', content: aiResponseText });
          console.log("Chat history updated:", chatHistory);
          // userInput.value is already cleared
          return; // Stop here, do not call the AI API
      }


      // Build the messages array for the API directly from chatHistory
      const msgs = [...chatHistory]; // Create a copy to send

      console.log("Sending message to AI:", msgs); // Log the message being sent to AI

      // Show AI placeholder and get a reference to its bubble
      const aiBubbleElement = addMessage("<em>Thinking...</em>", 'ai', true);


      try {
        const response = await puter.ai.chat(
          msgs,
          {
              model: modelName, // Use the defined model variable
              stream: true,
              temperature: temperatureValue // Use the defined temperature variable
            }
        );
        console.log("AI response received (stream)."); // Log response start
        let aiText = '';
        // No need to get aiBubble here, as aiBubbleElement is already the reference to the specific bubble

        for await (const part of response) {
          if (part?.text) {
            aiText += part.text;
            // Update the specific AI bubble with streamed content
            if (aiBubbleElement) {
                aiBubbleElement.innerHTML = ''; // Clear "Thinking..."
                aiBubbleElement.appendChild(renderMarkdown(aiText));
                messagesDiv.scrollTop = messagesDiv.scrollHeight; // Auto-scroll during streaming
            }
            // console.log("Streamed part:", part.text); // Log each streamed part (optional, can be noisy)
          }
        }
        console.log("AI response stream finished. Final text:", aiText); // Log final AI text

        // After streaming is complete, re-render the final AI message to add copy buttons
        if (aiBubbleElement) {
             aiBubbleElement.innerHTML = ''; // Clear the streamed content
             aiBubbleElement.appendChild(renderMarkdown(aiText)); // Render final markdown with code blocks
             // Manually add copy buttons after final render
             const codeBlocks = aiBubbleElement.querySelectorAll('pre');
             codeBlocks.forEach(pre => {
               const copyBtn = document.createElement('button');
               copyBtn.className = 'copy-code-btn';
               copyBtn.textContent = '📋 Copy';
               pre.parentNode.insertBefore(copyBtn, pre.nextSibling); // Insert after the pre element
             });
        }


        // Add the completed AI message to chat history
        chatHistory.push({ role: 'assistant', content: aiText });
        console.log("Chat history updated:", chatHistory); // Log updated chat history

      } catch (e) {
        console.error("Error during AI chat:", e); // Log any errors
        if (aiBubbleElement) {
            aiBubbleElement.innerHTML = `<span style="color:red;">Error: ${e.message}</span>`;
        }
        // Optionally, add an error message to chat history as an AI turnrenderMarkdown
        chatHistory.push({ role: 'assistant', content: `Error: ${e.message}` });
        console.log("Chat history updated with error:", chatHistory);
      }
    }

    sendBtn.onclick = sendMessage;

    // Use keydown for robust handling of Enter and Shift+Enter
    userInput.addEventListener('keydown', e => {
      if (e.key === 'Enter') {
        e.preventDefault(); // Always prevent default Enter behavior (newline or implicit form submission)

        if (e.ctrlKey) { // Ctrl + Enter: Submit
          sendMessage();
        } else { // Enter or Shift + Enter: Insert newline
          const start = userInput.selectionStart;
          const end = userInput.selectionEnd;
          userInput.value = userInput.value.substring(0, start) + '\n' + userInput.value.substring(end);
          userInput.selectionStart = userInput.selectionEnd = start + 1;
          autoGrowTextarea(userInput); // Adjust height after inserting newline
        }
      }
    });

    // Listen for input events to auto-grow textarea
    userInput.addEventListener('input', () => autoGrowTextarea(userInput));

    attachBtn.onclick = () => fileInput.click();

    fileInput.onchange = async (e) => {
      console.log("File input changed."); // Log file input change
      const file = e.target.files[0];
      if (!file) {
        console.log("No file selected."); // Log no file selected
        return;
      }
      console.log(`Selected file: ${file.name}, type: ${file.type}`); // Log selected file details
      try {
        if (
          file.type.startsWith('text/') ||
          file.name.endsWith('.js') ||
          file.name.endsWith('.rs') ||
          file.name.endsWith('.txt') ||
          file.name.endsWith('.md') || // Added markdown file support
          file.name.endsWith('.html') || // Added html file support
          file.name.endsWith('.css') // Added css file support
        ) {
          console.log("Reading text file."); // Log text file reading
          const text = await file.text();
          fileContentPrompt = text; // Only the file content, not the analyze message
          fileNamePrompt = `(${file.name})`;
          fileName = file.name;
          attachedFileSpan.textContent = `Loaded: ${file.name}`;
          console.log(`File loaded: ${file.name}`); // Log successful file load
          updateUnloadBtn();
          updateUserInputBox();
        } else if (file.type.startsWith('image/')) {
          console.log("Image file detected. Attempting upload."); // Log image handling
          const uploadedFiles = await puter.fs.upload(e.target.files);
          const uploaded = Array.isArray(uploadedFiles) ? uploadedFiles[0] : uploadedFiles;
          alert(
            "Image uploaded to: " +
              (uploaded.url || uploaded.path) +
              "\nYou need a public URL to send to Gemini."
          );
          console.log(`Image uploaded: ${uploaded.url || uploaded.path}`); // Log image upload success
          attachedFileSpan.textContent = '';
          fileContentPrompt = null;
          fileNamePrompt = null;
          fileName = null;
          updateUnloadBtn();
          updateUserInputBox();
        } else {
          console.warn(`Unsupported file type: ${file.type}`); // Log unsupported file type
          alert("Unsupported file type for direct Gemini input.");
          attachedFileSpan.textContent = '';
          fileContentPrompt = null;
          fileNamePrompt = null;
          fileName = null;
          updateUnloadBtn();
          updateUserInputBox();
        }
      } catch (err) {
        console.error("File handling failed:", err); // Log file handling errors
        alert("File upload failed: " + err.message);
        attachedFileSpan.textContent = '';
        fileContentPrompt = null;
        fileNamePrompt = null;
        fileName = null;
        updateUnloadBtn();
        updateUserInputBox();
      }
    };

    // Add event listener for copy buttons using delegation
    messagesDiv.addEventListener('click', async (event) => {
      if (event.target.classList.contains('copy-code-btn')) {
        const copyBtn = event.target;
        // Find the preceding pre element
        let preElement = copyBtn.previousElementSibling;
        while(preElement && preElement.tagName !== 'PRE') {
            preElement = preElement.previousElementSibling;
        }


        if (preElement && preElement.tagName === 'PRE') {
          const codeElement = preElement.querySelector('code');
          if (codeElement) {
            const codeToCopy = codeElement.textContent;

            try {
              await navigator.clipboard.writeText(codeToCopy);
              console.log("Code copied to clipboard.");
              const originalText = copyBtn.textContent;
              copyBtn.textContent = '✅ Copied!';
              setTimeout(() => {
                copyBtn.textContent = originalText;
              }, 2000); // Change back after 2 seconds
            } catch (err) {
              console.error("Failed to copy code:", err);
              copyBtn.textContent = '❌ Failed!';
              setTimeout(() => {
                 copyBtn.textContent = '📋 Copy';
              }, 2000);
            }
          }
        }
      }
    });


    // Initial state updates
    updateUnloadBtn();
    updateUserInputBox();
    console.log("Script initialized."); // Log script initialization
  </script>
</body>
</html>