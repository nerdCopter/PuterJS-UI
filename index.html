<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title></title> <!-- Placeholder title removed -->
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <script src="https://js.puter.com/v2/"></script>
  <style>
    body {
      font-family: Georgia, "Times New Roman", Times, serif; /* Changed to a standard serif font stack */
      background: #f6f8fa;
      margin: 0;
      padding: 0;
    }
    #container { width: 80vw; margin: 40px auto; background: #fff; border-radius: 10px; box-shadow: 0 4px 24px rgba(0,0,0,0.08); padding: 24px; }
    #messages { min-height: 10px; margin-bottom: 6px; border-bottom: 1px solid #eee; padding-bottom: 16px; }
    .msg { margin: 8px 0; } /* Reintroduced vertical margin for whitespace between bubbles */
    .msg.user { text-align: right; color: #000000; } /* Changed user message color to black */
    .msg.ai { text-align: left; color: #000000; } /* Changed AI message color to black */
    .msg .bubble {
      display: inline-block;
      padding: 4px 6px; /* Adjusted for very short vertical (4px) and slightly narrower horizontal (6px) padding */
      border-radius: 4px; /* Adjusted border-radius to match smaller padding */
      margin-bottom: 0; /* Ensure no extra margin below the bubble itself */
    }
    .msg.user .bubble { background: #dbeafe; }
    /* Specific style for the thinking bubble */
    .msg.ai .bubble.thinking-bubble {
      background: #ffbf00; /* Amber color */
      color: #333; /* Darker text color for contrast on amber */
    }
    .msg.ai .bubble { background: #f3f4f6; } /* Default AI bubble background */

    #input-row { display: flex; gap: 8px; margin-top: 12px; }
    #user-input {
      flex: 1;
      padding: 10px;
      border: 1px solid #d1d5db;
      border-radius: 8px;
      font-size: 1rem;
      resize: none; /* Prevent manual resizing by the user */
      overflow-y: hidden; /* Hide scrollbar, as we're auto-growing */
      min-height: 40px; /* Set a minimum height for the textarea */
      box-sizing: border-box; /* Include padding and border in the element's total width and height */
      height: auto; /* Allow height to be controlled by JS */
    }
    #send-btn, #attach-btn, #unload-btn { padding: 0 18px; border: none; border-radius: 8px; background: #2563eb; color: #fff; font-size: 1rem; cursor: pointer; }
    #attach-btn { background: #6b7280; }
    #unload-btn { background: #e11d48; }
    #send-btn:hover { background: #1d4ed8; }
    #attach-btn:hover { background: #374151; }
    #unload-btn:hover { background: #be123c; }
    #file-input { display: none; }
    #attached-file { font-size: 0.95em; color: #374151; margin-right: 8px; margin-top: 2px; }
    .markdown-body {
      font-size: 1.3em; /* Font size for non-code text */
      line-height: 1.2; /* Adjusted line-height for more compact text lines */
    }

    /* Styles for markdown code/pre */
    .markdown-body pre {
      border-radius: 3px;
      padding: 4px;
      /* Programmer font */
      font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', 'Liberation Mono', 'Menlo', 'Courier New', monospace;
      font-size: 0.8em; /* Decreased code font size relative to the new markdown-body size */
    }
    .markdown-body code { /* Inline code */
      border-radius: 3px;
      padding: 2px 4px;
      font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', 'Liberation Mono', 'Menlo', 'Courier New', monospace;
      font-size: 0.8em;
    }

    /* Remove default top/bottom margins from common markdown-generated block elements */
    .markdown-body p,
    .markdown-body ul,
    .markdown-body ol,
    .markdown-body h1,
    .markdown-body h2,
    .markdown-body h3,
    .markdown-body h4,
    .markdown-body h5,
    .markdown-body h6 {
      margin-top: 2px; /* Very small top margin */
      margin-bottom: 2px; /* Very small bottom margin */
    }

    /* Style for the copy button */
    .copy-code-btn {
      display: inline-block; /* Changed to inline-block for float */
      margin-top: 5px; /* Margin to separate from the code block above */
      padding: 4px 8px;
      font-size: 0.8em;
      cursor: pointer;
      background-color: #2563eb; /* Changed to blue */
      border: 1px solid #1d4ed8; /* Darker blue border */
      border-radius: 4px;
      color: #fff; /* White text */
      float: right; /* Position to the right */
      clear: both; /* Ensure it's below the pre if pre is block */
      user-select: none; /* Prevent text selection on the button */
    }

    .copy-code-btn:hover {
      background-color: #1d4ed8; /* Darker blue on hover */
    }

    .copy-code-btn:active {
      background-color: #111827; /* Even darker blue on active */
    }

    /* Styles for model selection */
    #model-selection {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 16px;
    }
    #model-selection label {
      font-size: 0.95em;
      color: #374151;
    }
    #model-select {
      padding: 8px;
      border: 1px solid #d1d5db;
      border-radius: 8px;
      font-size: 0.95em;
      background-color: #fff;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <div id="container">
    <h2 id="chat-title"></h2> <!-- Added ID for dynamic update -->
    <div id="model-selection">
      <label for="model-select">Select Model:</label>
      <select id="model-select"></select>
    </div>
    <div id="messages"></div>
    <div id="input-row">
      <span id="attached-file"></span>
      <textarea id="user-input" placeholder="Type your message or attach a file..." autocomplete="off" rows="1"></textarea>
      <button id="attach-btn" title="Attach file">ðŸ“Ž</button>
      <input type="file" id="file-input" />
      <button id="unload-btn">Abort File</button>
      <button id="send-btn">Send</button>
    </div>
  </div>
  <script>
    // Configure marked.js to convert GFM line breaks to <br> tags
    marked.setOptions({
      breaks: true
    });

    const messagesDiv = document.getElementById('messages');
    const userInput = document.getElementById('user-input');
    const sendBtn = document.getElementById('send-btn');
    const attachBtn = document.getElementById('attach-btn');
    const unloadBtn = document.getElementById('unload-btn');
    const fileInput = document.getElementById('file-input');
    const attachedFileSpan = document.getElementById('attached-file');
    const chatTitle = document.getElementById('chat-title'); // Get the chat title element
    const modelSelect = document.getElementById('model-select'); // Get the model select element

    let fileContentPrompt = null; // Stores content of text-based files
    let attachedImageURL = null;  // Stores public URL of uploaded image
    let fileName = null;          // Stores the name of the attached file (text or image)
    let chatHistory = [];         // Stores the visible conversation history (text only for simplicity)

    // Reusable variable for the file analysis prompt template
    const fileAnalysisPromptTemplate = (name) => `Analyze \`${name}\` and provide a brief summary of its function.`;

    // Hardcoded list of models from Puter.js documentation, now including user's suggested models
    const availableModels = [
      "codestral-latest",
      "openrouter:mistralai/codestral-2501",
      "openrouter:mistralai/codestral-2501:free",
      "openrouter:deepseek/deepseek-coder",
      "openrouter:deepseek/deepseek-coder:free",
      "openrouter:deepseek/deepseek-reasoner",
      "openrouter:deepseek/deepseek-reasoner:free",
      "gpt-4.5-preview",
      "gpt-4.1",
      "openrouter:openai/gpt-4o-2024-11-20",
      "openrouter:openai/gpt-4o-2024-08-06",
      "openrouter:openai/gpt-4o",
      "openrouter:openai/gpt-4o:free",
      "claude-3-7-sonnet",
      "claude-3-5-sonnet",
      "claude-opus-4",
      "openrouter:anthropic/claude-3.7-sonnet",
      "openrouter:anthropic/claude-3.7-sonnet:free",
      "openrouter:anthropic/claude-3.5-sonnet",
      "openrouter:anthropic/claude-3.5-sonnet:free",
      "openrouter:anthropic/claude-opus-4",
      "openrouter:anthropic/claude-opus-4:beta",
      "openrouter:qwen/qwen-2.5-coder-32b-instruct",
      "openrouter:qwen/qwen-2.5-coder-32b-instruct:free",
      "openrouter:qwen/qwen2.5-coder-7b-instruct",
      "openrouter:qwen/qwen2.5-coder-7b-instruct:free",
      "openrouter:qwen/qwen3-235b-a22b",
      "openrouter:qwen/qwen3-235b-a22b:free",
      "openrouter:qwen/qwen3-32b",
      "openrouter:qwen/qwen3-32b:free",
      "openrouter:qwen/qwen3-14b",
      "openrouter:qwen/qwen3-14b:free",
      "openrouter:qwen/qwen3-30b-a3b",
      "openrouter:qwen/qwen3-30b-a3b:free",
      "openrouter:ai21/jamba-1.6-large",
      "openrouter:ai21/jamba-1.6-large:free",
      "openrouter:ai21/jamba-1.6-mini",
      "openrouter:ai21/jamba-1.6-mini:free",
      "openrouter:microsoft/phi-4-reasoning-plus",
      "openrouter:microsoft/phi-4-reasoning-plus:free",
      "google/gemini-2.5-flash-preview-05-20:thinking",
      "google/gemini-2.5-flash-preview:thinking",
      "openrouter:google/gemini-2.5-flash-preview-05-20",
      "openrouter:google/gemini-2.5-flash-preview",
      "openrouter:google/gemini-2.5-flash-preview-05-20:free",
      "openrouter:google/gemini-2.5-flash-preview:free",
    ];

    // Default model and temperature
    let selectedModel = "google/gemini-2.5-flash-preview-05-20:thinking"; // Default to one of the newly added models
    const temperatureValue = 0.3;

    function updateChatTitle() {
      document.title = `Puter.JS: ${selectedModel} (Temp: ${temperatureValue})`;
      chatTitle.innerHTML = `<a href="https://developer.puter.com/tutorials/" target="_blank">Puter.JS</a>: ${selectedModel} (Temp: ${temperatureValue})`;
    }

    function populateModelSelect() {
        availableModels.forEach(model => {
            const option = document.createElement('option');
            option.value = model;
            option.textContent = model;
            modelSelect.appendChild(option);
        });
        // Set the default selected model
        modelSelect.value = selectedModel;
    }

    // Event listener for model selection change
    modelSelect.addEventListener('change', () => {
        selectedModel = modelSelect.value;
        updateChatTitle();
        console.log(`Model changed to: ${selectedModel}`);
    });


    function renderMarkdown(md) {
      const div = document.createElement('div');
      div.className = 'markdown-body';
      div.innerHTML = marked.parse(md);
      return div;
    }

    function addMessage(text, sender = 'user', isStreamingPlaceholder = false) {
      console.log(`Adding message: "${text}" from ${sender}. Is placeholder: ${isStreamingPlaceholder}`);
      const msgDiv = document.createElement('div');
      msgDiv.className = `msg ${sender}`;
      let bubble = `<div class="bubble"></div>`;
      msgDiv.innerHTML = bubble;
      const bubbleElement = msgDiv.querySelector('.bubble');

      if (text) {
        if (isStreamingPlaceholder) {
           bubbleElement.innerHTML = text; // Add "Thinking..." directly
           if (sender === 'ai') { // Only apply thinking style to AI placeholder
             bubbleElement.classList.add('thinking-bubble'); // ADDED: Apply amber class
           }
        } else {
          const renderedContent = renderMarkdown(text);
          bubbleElement.appendChild(renderedContent);

          // If it's a completed AI message, add copy buttons to code blocks
          if (sender === 'ai') {
            const codeBlocks = renderedContent.querySelectorAll('pre');
            codeBlocks.forEach(pre => {
              const copyBtn = document.createElement('button');
              copyBtn.className = 'copy-code-btn';
              copyBtn.textContent = 'ðŸ“‹ Copy';
              pre.parentNode.insertBefore(copyBtn, pre.nextSibling); // Insert after the pre element
            });
          }
        }
      }
      messagesDiv.appendChild(msgDiv);
      messagesDiv.scrollTop = messagesDiv.scrollHeight; // Auto-scroll to bottom
      return bubbleElement; // Return the bubble element for streaming updates
    }

    // Function to auto-grow the textarea
    function autoGrowTextarea(element) {
      element.style.height = 'auto'; // Reset height to recalculate scrollHeight
      element.style.height = element.scrollHeight + 'px'; // Set height to scrollHeight
    }

    function updateUnloadBtn() {
      console.log(`Updating unload button visibility. fileContentPrompt: ${!!fileContentPrompt}, attachedImageURL: ${!!attachedImageURL}`);
      if (fileContentPrompt || attachedImageURL) {
        unloadBtn.style.display = "inline-block";
      } else {
        unloadBtn.style.display = "none";
      }
    }

    function updateUserInputBox() {
      console.log(`Updating user input box. Current fileName: ${fileName}, attachedImageURL: ${!!attachedImageURL}`);
      if (fileName) {
        if (attachedImageURL) {
          userInput.value = `Analyze this image (${fileName}). Confirm receipt and wait for my request.`;
        } else {
          userInput.value = fileAnalysisPromptTemplate(fileName);
        }
      } else {
        userInput.value = '';
        userInput.placeholder = 'Type your message or attach a file...';
      }
      userInput.readOnly = false; // Always ensure it's editable unless explicitly set otherwise
      autoGrowTextarea(userInput); // Adjust height after updating value
    }

    unloadBtn.onclick = () => {
      console.log("Unload button clicked. Clearing file state.");
      fileContentPrompt = null;
      attachedImageURL = null;
      fileName = null;
      attachedFileSpan.textContent = '';
      updateUnloadBtn();
      updateUserInputBox();
    };

    async function sendMessage() {
      console.log("sendMessage called.");
      let text = userInput.value.trim();
      let userMessageForDisplay = text; // What the user sees they sent

      // Prepare message parts for the model
      let messageContentForModelParts = [];

      // Add user's typed text as a part if not empty
      if (userMessageForDisplay) {
          messageContentForModelParts.push({ text: userMessageForDisplay });
      }

      // Add file content as a part if a text file is attached
      if (fileContentPrompt) {
          messageContentForModelParts.push({ text: fileContentPrompt });
      }
      // Add image URL as a part if an image is attached
      else if (attachedImageURL) {
          messageContentForModelParts.push({ image_url: { url: attachedImageURL } });
      }

      // If no text and no file/image, do nothing
      if (messageContentForModelParts.length === 0) {
          console.log("No content to send.");
          return;
      }

      // Clear input field and file state immediately after getting its value
      userInput.value = '';
      autoGrowTextarea(userInput); // Reset height after clearing

      // Clear file state variables after they've been used for this message
      fileContentPrompt = null;
      attachedImageURL = null;
      fileName = null;
      attachedFileSpan.textContent = '';
      updateUnloadBtn();
      updateUserInputBox(); // Reset input box and state

      // Add the user message to the display (using the text the user saw/typed)
      addMessage(userMessageForDisplay, 'user');

      // Add the user message content (what was sent to the model) to chat history
      // For simplicity in chatHistory, we'll store the display text.
      // For the model API call, we use the structured messageContentForModelParts.
      chatHistory.push({ role: 'user', content: userMessageForDisplay }); // Store display text for history

      // Check for the specific "wait for my request" command
      if (userMessageForDisplay.toLowerCase() === "wait for my request") {
          console.log("User requested to wait. Responding with 'Awaiting your command.'");
          const aiResponseText = "Awaiting your command.";
          addMessage(aiResponseText, 'ai');
          chatHistory.push({ role: 'assistant', content: aiResponseText });
          console.log("Chat history updated:", chatHistory);
          return; // Stop here, do not call the AI API
      }

      // Build the messages array for the API directly from chatHistory for text-only turns,
      // and use messageContentForModelParts for the current turn.
      const msgs = [];
      for (const entry of chatHistory) {
          // For simplicity, assuming chatHistory stores text.
          // If full multimodal history is needed for the model, chatHistory would need to store parts.
          msgs.push({ role: entry.role, content: entry.content });
      }
      // Replace the last user message in msgs with the actual structured parts for the current turn
      // This ensures the model receives the image/file content for the current turn.
      msgs[msgs.length - 1].content = messageContentForModelParts;


      console.log("Sending message to AI:", msgs);

      // Show AI placeholder and get a reference to its bubble
      const aiBubbleElement = addMessage("<em>Thinking...</em>", 'ai', true);

      try {
        const response = await puter.ai.chat(
          msgs,
          {
              model: selectedModel, // Use the selected model from the dropdown
              stream: true,
              temperature: temperatureValue
            }
        );
        console.log("AI response received (stream).");
        let aiText = '';

        for await (const part of response) {
          if (part?.text) {
            aiText += part.text;
            // Update the specific AI bubble with streamed content
            if (aiBubbleElement) {
                aiBubbleElement.innerHTML = ''; // Clear "Thinking..."
                aiBubbleElement.appendChild(renderMarkdown(aiText));
                messagesDiv.scrollTop = messagesDiv.scrollHeight;
            }
          }
        }
        console.log("AI response stream finished. Final text:", aiText);

        // After streaming is complete, re-render the final AI message to add copy buttons
        if (aiBubbleElement) {
             aiBubbleElement.innerHTML = '';
             aiBubbleElement.appendChild(renderMarkdown(aiText));
             aiBubbleElement.classList.remove('thinking-bubble'); // REMOVED: Remove amber class
             const codeBlocks = aiBubbleElement.querySelectorAll('pre');
             codeBlocks.forEach(pre => {
               const copyBtn = document.createElement('button');
               copyBtn.className = 'copy-code-btn';
               copyBtn.textContent = 'ðŸ“‹ Copy';
               pre.parentNode.insertBefore(copyBtn, pre.nextSibling);
             });
        }

        // Add the completed AI message to chat history
        chatHistory.push({ role: 'assistant', content: aiText });
        console.log("Chat history updated:", chatHistory);

      } catch (e) {
        console.error("Error during AI chat:", e);
        if (aiBubbleElement) {
            aiBubbleElement.innerHTML = `<span style="color:red;">Error: ${e.message}</span>`;
            aiBubbleElement.classList.remove('thinking-bubble'); // REMOVED: Remove amber class on error
        }
        chatHistory.push({ role: 'assistant', content: `Error: ${e.message}` });
        console.log("Chat history updated:", chatHistory);
      }
    }

    sendBtn.onclick = sendMessage;

    // Use keydown for robust handling of Enter and Shift+Enter
    userInput.addEventListener('keydown', e => {
      if (e.key === 'Enter') {
        e.preventDefault(); // Always prevent default Enter behavior

        if (e.ctrlKey) { // Ctrl + Enter: Submit
          sendMessage();
        } else { // Enter or Shift + Enter: Insert newline
          const start = userInput.selectionStart;
          const end = userInput.selectionEnd;
          userInput.value = userInput.value.substring(0, start) + '\n' + userInput.value.substring(end);
          userInput.selectionStart = userInput.selectionEnd = start + 1;
          autoGrowTextarea(userInput); // Adjust height after inserting newline
        }
      }
    });

    // Listen for input events to auto-grow textarea
    userInput.addEventListener('input', () => autoGrowTextarea(userInput));

    attachBtn.onclick = () => fileInput.click();

    fileInput.onchange = async (e) => {
      console.log("File input changed.");
      const file = e.target.files[0];
      if (!file) {
        console.log("No file selected.");
        return;
      }
      console.log(`Selected file: ${file.name}, type: ${file.type}`);
      attachedFileSpan.textContent = `Loading: ${file.name}...`; // Show loading indicator

      try {
        if (
          file.type.startsWith('text/') ||
          file.name.endsWith('.bash') ||
          file.name.endsWith('.c') ||
          file.name.endsWith('.cfg') ||
          file.name.endsWith('.conf') ||
          file.name.endsWith('.cpp') ||
          file.name.endsWith('.csv') ||
          file.name.endsWith('.css') ||
          file.name.endsWith('.env') ||
          file.name.endsWith('.gitignore') ||
          file.name.endsWith('.go') ||
          file.name.endsWith('.h') ||
          file.name.endsWith('.hpp') ||
          file.name.endsWith('.html') ||
          file.name.endsWith('.ini') ||
          file.name.endsWith('.java') ||
          file.name.endsWith('.js') ||
          file.name.endsWith('.json') ||
          file.name.endsWith('.jsx') ||
          file.name.endsWith('.log') ||
          file.name.endsWith('.md') ||
          file.name.endsWith('.php') ||
          file.name.endsWith('.pl') ||
          file.name.endsWith('.py') ||
          file.name.endsWith('.rb') ||
          file.name.endsWith('.rs') ||
          file.name.endsWith('.rst') ||
          file.name.endsWith('.sh') ||
          file.name.endsWith('.sql') ||
          file.name.endsWith('.tex') ||
          file.name.endsWith('.toml') ||
          file.name.endsWith('.ts') ||
          file.name.endsWith('.tsx') ||
          file.name.endsWith('.txt') ||
          file.name.endsWith('.vue') ||
          file.name.endsWith('.xml') ||
          file.name.endsWith('.yaml') ||
          file.name.endsWith('.yml') ||
          file.name.endsWith('.zsh')
        ) {
          console.log("Reading text file.");
          const text = await file.text();
          fileContentPrompt = text; // Store text content
          attachedImageURL = null; // Clear any previous image
          fileName = file.name;
          attachedFileSpan.textContent = `Loaded: ${file.name}`;
          console.log(`Text file loaded: ${file.name}`);
          updateUnloadBtn();
          updateUserInputBox();
        } else if (file.type.startsWith('image/')) {
          console.log("Image file detected. Attempting upload.");
          // Upload the image to Puter FS
          const uploadedFiles = await puter.fs.upload(e.target.files);
          const uploaded = Array.isArray(uploadedFiles) ? uploadedFiles[0] : uploadedFiles;

          if (uploaded && uploaded.url) {
              attachedImageURL = uploaded.url; // Store the public URL
              fileContentPrompt = null; // Clear any previous text file
              fileName = file.name;
              attachedFileSpan.textContent = `Loaded Image: ${file.name}`;
              console.log(`Image uploaded and URL stored: ${attachedImageURL}`);
              updateUnloadBtn();
              updateUserInputBox(); // Update input box with image prompt
          } else {
              alert("Image upload failed: No URL returned.");
              console.error("Image upload failed: No URL returned.", uploaded);
              attachedFileSpan.textContent = '';
              attachedImageURL = null;
              fileName = null;
              updateUnloadBtn();
              updateUserInputBox();
          }
        } else {
          console.warn(`Unsupported file type: ${file.type}`);
          alert("Unsupported file type for direct Gemini input.");
          attachedFileSpan.textContent = '';
          fileContentPrompt = null;
          attachedImageURL = null;
          fileName = null;
          updateUnloadBtn();
          updateUserInputBox();
        }
      } catch (err) {
        console.error("File handling failed:", err);
        alert("File upload failed: " + err.message);
        attachedFileSpan.textContent = '';
        fileContentPrompt = null;
        attachedImageURL = null;
        fileName = null;
        updateUnloadBtn();
        updateUserInputBox();
      } finally {
        // Clear the file input value so that selecting the same file again triggers onchange
        e.target.value = '';
      }
    };

    // Add event listener for copy buttons using delegation
    messagesDiv.addEventListener('click', async (event) => {
      if (event.target.classList.contains('copy-code-btn')) {
        const copyBtn = event.target;
        // Find the preceding pre element
        let preElement = copyBtn.previousElementSibling;
        while(preElement && preElement.tagName !== 'PRE') {
            preElement = preElement.previousElementSibling;
        }

        if (preElement && preElement.tagName === 'PRE') {
          const codeElement = preElement.querySelector('code');
          if (codeElement) {
            const codeToCopy = codeElement.textContent;

            try {
              await navigator.clipboard.writeText(codeToCopy);
              console.log("Code copied to clipboard.");
              const originalText = copyBtn.textContent;
              copyBtn.textContent = 'âœ… Copied!';
              setTimeout(() => {
                copyBtn.textContent = originalText;
              }, 2000); // Change back after 2 seconds
            } catch (err) {
              console.error("Failed to copy code:", err);
              copyBtn.textContent = 'âŒ Failed!';
              setTimeout(() => {
                 copyBtn.textContent = 'ðŸ“‹ Copy';
              }, 2000);
            }
          }
        }
      }
    });

    // Initial state updates
    populateModelSelect(); // Populate the dropdown on load
    updateUnloadBtn();
    updateUserInputBox();
    updateChatTitle(); // Set initial chat title
    console.log("Script initialized.");
  </script>
</body>
</html>